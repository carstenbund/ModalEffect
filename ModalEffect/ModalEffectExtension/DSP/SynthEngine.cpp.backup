/**
 * @file SynthEngine.cpp
 * @brief Implementation of the Modal Attractors synthesis engine
 */

#include "SynthEngine.h"
#include "VoiceAllocator.h"
#include "TopologyEngine.h"
#include "ModalVoice.h"
#include <algorithm>

// Parameter IDs (should match ModalEffectExtensionParameterAddresses.h)
enum ParamID {
    kParam_MasterGain = 0,
    kParam_CouplingStrength = 1,
    kParam_Topology = 2,
    kParam_NodeCount = 3,
    kParam_Mode0_Frequency = 4,
    kParam_Mode0_Damping = 5,
    kParam_Mode0_Weight = 6,
    kParam_Mode1_Frequency = 7,
    kParam_Mode1_Damping = 8,
    kParam_Mode1_Weight = 9,
    kParam_Mode2_Frequency = 10,
    kParam_Mode2_Damping = 11,
    kParam_Mode2_Weight = 12,
    kParam_Mode3_Frequency = 13,
    kParam_Mode3_Damping = 14,
    kParam_Mode3_Weight = 15,
    kParam_PokeStrength = 16,
    kParam_PokeDuration = 17,
    kParam_Polyphony = 18,
    kParam_Personality = 19
};

SynthEngine::SynthEngine(uint32_t maxPolyphony)
    : voiceAllocator_(nullptr)
    , topologyEngine_(nullptr)
    , voicePointers_(nullptr)
    , maxPolyphony_(maxPolyphony)
    , sampleRate_(44100.0)
    , maxFrames_(0)
    , channels_(2)
    , initialized_(false)
    , controlRateCounter_(0)
    // Global parameters - match defaults from Parameters.swift
    , masterGain_(0.7f)
    , couplingStrength_(0.3f)
    , topologyType_(0)
    , nodeCount_(16)
    // Mode parameters - match defaults from Parameters.swift
    , mode0_frequency_(1.0f)
    , mode0_damping_(1.0f)
    , mode0_weight_(1.0f)
    , mode1_frequency_(2.0f)
    , mode1_damping_(1.2f)
    , mode1_weight_(0.8f)
    , mode2_frequency_(3.0f)
    , mode2_damping_(1.5f)
    , mode2_weight_(0.6f)
    , mode3_frequency_(4.5f)
    , mode3_damping_(2.0f)
    , mode3_weight_(0.4f)
    // Excitation parameters
    , pokeStrength_(0.5f)
    , pokeDuration_(10.0f)
    // Voice parameters
    , polyphony_(16.0f)
    , personality_(0.0f)
{
    // Allocate DSP components (done once at construction)
    voiceAllocator_ = new VoiceAllocator(maxPolyphony);
    topologyEngine_ = new TopologyEngine(maxPolyphony);

    // Pre-allocate voice pointer array (CRITICAL: no allocation in render!)
    voicePointers_ = new ModalVoice*[maxPolyphony];
}

SynthEngine::~SynthEngine() {
    if (voicePointers_) {
        delete[] voicePointers_;
        voicePointers_ = nullptr;
    }

    if (voiceAllocator_) {
        delete voiceAllocator_;
        voiceAllocator_ = nullptr;
    }

    if (topologyEngine_) {
        delete topologyEngine_;
        topologyEngine_ = nullptr;
    }
}

void SynthEngine::prepare(double sampleRate, uint32_t maxFrames, uint32_t channels) {
    sampleRate_ = sampleRate;
    maxFrames_ = maxFrames;
    channels_ = channels;

    // Initialize voice allocator
    voiceAllocator_->initialize(static_cast<float>(sampleRate));

    // Set default topology
    topologyEngine_->generateTopology(TopologyType::Ring, couplingStrength_);

    initialized_ = true;
}

void SynthEngine::reset() {
    if (!initialized_) return;

    // Release all voices
    voiceAllocator_->allNotesOff();
    controlRateCounter_ = 0;
}

void SynthEngine::render(const EventQueue& events, float* outL, float* outR, uint32_t numFrames) {
    if (!initialized_) {
        // Return silence
        memset(outL, 0, numFrames * sizeof(float));
        if (outR != outL) {
            memset(outR, 0, numFrames * sizeof(float));
        }
        return;
    }

    // Sample-accurate event processing pattern:
    // Process events in order, rendering slices between events

    uint32_t lastOffset = 0;

    for (uint32_t i = 0; i < events.count(); i++) {
        const SynthEvent& event = events[i];
        int32_t offset = event.sampleOffset;

        // Clamp offset to valid range
        if (offset < 0) offset = 0;
        if (offset > static_cast<int32_t>(numFrames)) offset = numFrames;

        // Render slice before this event
        if (offset > static_cast<int32_t>(lastOffset)) {
            uint32_t sliceFrames = offset - lastOffset;
            renderSlice(outL + lastOffset, outR + lastOffset, lastOffset, sliceFrames);
        }

        // Process event at this sample offset
        processEvent(event);

        lastOffset = offset;
    }

    // Render remaining frames after all events
    if (lastOffset < numFrames) {
        uint32_t remainingFrames = numFrames - lastOffset;
        renderSlice(outL + lastOffset, outR + lastOffset, lastOffset, remainingFrames);
    }
}

void SynthEngine::processEvent(const SynthEvent& event) {
    switch (event.type) {
        case EventType::NoteOn:
            voiceAllocator_->noteOn(event.noteOn.note, event.noteOn.velocity);
            break;

        case EventType::NoteOff:
            voiceAllocator_->noteOff(event.noteOff.note);
            break;

        case EventType::PitchBend:
            voiceAllocator_->setPitchBend(event.pitchBend.value);
            break;

        case EventType::CC:
            // Handle CC messages if needed
            // Could map to parameters
            break;

        case EventType::Parameter:
            setParameter(event.parameter.paramId, event.parameter.value);
            break;
    }
}

void SynthEngine::renderSlice(float* outL, float* outR, uint32_t startFrame, uint32_t numFrames) {
    // Update control-rate parameters periodically
    controlRateCounter_ += numFrames;
    if (controlRateCounter_ >= CONTROL_RATE_SAMPLES) {
        updateControlRate();
        controlRateCounter_ = 0;
    }

    // Render voices
    voiceAllocator_->renderAudio(outL, outR, numFrames);

    // Apply master gain
    for (uint32_t i = 0; i < numFrames; i++) {
        outL[i] *= masterGain_;
        if (outR != outL) {
            outR[i] *= masterGain_;
        }
    }
}

void SynthEngine::updateControlRate() {
    // Update voice state at control rate
    voiceAllocator_->updateVoices();

    // Update coupling (FIXED: no allocation, use pre-allocated array)
    for (uint32_t i = 0; i < maxPolyphony_; i++) {
        voicePointers_[i] = voiceAllocator_->getVoice(i);
    }
    topologyEngine_->updateCoupling(voicePointers_, maxPolyphony_);
}

void SynthEngine::setParameter(uint32_t paramId, float value) {
    switch (paramId) {
        case kParam_MasterGain:
            masterGain_ = value;
            break;

        case kParam_CouplingStrength:
            couplingStrength_ = value;
            topologyEngine_->setCouplingStrength(value);
            break;

        case kParam_Topology: {
            topologyType_ = static_cast<int>(value);

            // Map parameter value to topology type
            TopologyType topo = TopologyType::Ring;
            switch (topologyType_) {
                case 0: topo = TopologyType::Ring; break;
                case 1: topo = TopologyType::SmallWorld; break;
                case 2: topo = TopologyType::Clustered; break;
                case 3: topo = TopologyType::HubSpoke; break;
                case 4: topo = TopologyType::Random; break;
                case 5: topo = TopologyType::Complete; break;
                case 6: topo = TopologyType::None; break;
            }

            topologyEngine_->generateTopology(topo, couplingStrength_);
            break;
        }

        case kParam_NodeCount: {
            uint32_t newCount = static_cast<uint32_t>(value);
            if (newCount < 1) newCount = 1;
            if (newCount > 16) newCount = 16;

            if (newCount != nodeCount_) {
                nodeCount_ = newCount;

                // Update voice allocator to limit active voices
                if (voiceAllocator_) {
                    voiceAllocator_->setNodeCount(newCount);
                }

                // Regenerate topology for new node count
                if (topologyEngine_ && voiceAllocator_) {
                    topologyEngine_->generateTopology(
                        static_cast<TopologyType>(topologyType_),
                        couplingStrength_
                    );
                }
            }
            break;
        }

        // Mode 0 parameters
        case kParam_Mode0_Frequency:
            mode0_frequency_ = value;
            if (voiceAllocator_) {
                voiceAllocator_->setMode(0, value, mode0_damping_, mode0_weight_);
            }
            break;
        case kParam_Mode0_Damping:
            mode0_damping_ = value;
            if (voiceAllocator_) {
                voiceAllocator_->setMode(0, mode0_frequency_, value, mode0_weight_);
            }
            break;
        case kParam_Mode0_Weight:
            mode0_weight_ = value;
            if (voiceAllocator_) {
                voiceAllocator_->setMode(0, mode0_frequency_, mode0_damping_, value);
            }
            break;

        // Mode 1 parameters
        case kParam_Mode1_Frequency:
            mode1_frequency_ = value;
            if (voiceAllocator_) {
                voiceAllocator_->setMode(1, value, mode1_damping_, mode1_weight_);
            }
            break;
        case kParam_Mode1_Damping:
            mode1_damping_ = value;
            if (voiceAllocator_) {
                voiceAllocator_->setMode(1, mode1_frequency_, value, mode1_weight_);
            }
            break;
        case kParam_Mode1_Weight:
            mode1_weight_ = value;
            if (voiceAllocator_) {
                voiceAllocator_->setMode(1, mode1_frequency_, mode1_damping_, value);
            }
            break;

        // Mode 2 parameters
        case kParam_Mode2_Frequency:
            mode2_frequency_ = value;
            if (voiceAllocator_) {
                voiceAllocator_->setMode(2, value, mode2_damping_, mode2_weight_);
            }
            break;
        case kParam_Mode2_Damping:
            mode2_damping_ = value;
            if (voiceAllocator_) {
                voiceAllocator_->setMode(2, mode2_frequency_, value, mode2_weight_);
            }
            break;
        case kParam_Mode2_Weight:
            mode2_weight_ = value;
            if (voiceAllocator_) {
                voiceAllocator_->setMode(2, mode2_frequency_, mode2_damping_, value);
            }
            break;

        // Mode 3 parameters
        case kParam_Mode3_Frequency:
            mode3_frequency_ = value;
            if (voiceAllocator_) {
                voiceAllocator_->setMode(3, value, mode3_damping_, mode3_weight_);
            }
            break;
        case kParam_Mode3_Damping:
            mode3_damping_ = value;
            if (voiceAllocator_) {
                voiceAllocator_->setMode(3, mode3_frequency_, value, mode3_weight_);
            }
            break;
        case kParam_Mode3_Weight:
            mode3_weight_ = value;
            if (voiceAllocator_) {
                voiceAllocator_->setMode(3, mode3_frequency_, mode3_damping_, value);
            }
            break;

        // Excitation parameters
        case kParam_PokeStrength:
            pokeStrength_ = value;
            if (voiceAllocator_) {
                voiceAllocator_->setPokeStrength(value);
            }
            break;
        case kParam_PokeDuration:
            pokeDuration_ = value;
            if (voiceAllocator_) {
                voiceAllocator_->setPokeDuration(value);
            }
            break;

        // Voice parameters
        case kParam_Polyphony:
            polyphony_ = value;
            break;
        case kParam_Personality:
            personality_ = value;
            if (voiceAllocator_) {
                voiceAllocator_->setPersonality(static_cast<node_personality_t>(static_cast<int>(value)));
            }
            break;

        default:
            break;
    }
}

float SynthEngine::getParameter(uint32_t paramId) const {
    switch (paramId) {
        // Global parameters
        case kParam_MasterGain:
            return masterGain_;
        case kParam_CouplingStrength:
            return couplingStrength_;
        case kParam_Topology:
            return static_cast<float>(topologyType_);
        case kParam_NodeCount:
            return static_cast<float>(nodeCount_);

        // Mode 0 parameters
        case kParam_Mode0_Frequency:
            return mode0_frequency_;
        case kParam_Mode0_Damping:
            return mode0_damping_;
        case kParam_Mode0_Weight:
            return mode0_weight_;

        // Mode 1 parameters
        case kParam_Mode1_Frequency:
            return mode1_frequency_;
        case kParam_Mode1_Damping:
            return mode1_damping_;
        case kParam_Mode1_Weight:
            return mode1_weight_;

        // Mode 2 parameters
        case kParam_Mode2_Frequency:
            return mode2_frequency_;
        case kParam_Mode2_Damping:
            return mode2_damping_;
        case kParam_Mode2_Weight:
            return mode2_weight_;

        // Mode 3 parameters
        case kParam_Mode3_Frequency:
            return mode3_frequency_;
        case kParam_Mode3_Damping:
            return mode3_damping_;
        case kParam_Mode3_Weight:
            return mode3_weight_;

        // Excitation parameters
        case kParam_PokeStrength:
            return pokeStrength_;
        case kParam_PokeDuration:
            return pokeDuration_;

        // Voice parameters
        case kParam_Polyphony:
            return polyphony_;
        case kParam_Personality:
            return personality_;

        default:
            return 0.0f;
    }
}
